'comment': 'Specificities of Fortran >= 90'
'fileTypes': [
  'f90'
  'F90'
  'f95'
  'F95'
  'f03'
  'F03'
  'f08'
  'F08'
]
'firstLineMatch': '(?i)-[*]- mode: f90 -[*]-'
'name': 'Fortran - Modern'
'patterns': [
  {
    'include': 'source.fortran'
  }
  {'include': '#interface-blocks'}
  {
    'name': 'meta.derived-type.definition.fortran2008'
    'begin': '(?i)^\\s*(type)\\b(?![\\t ]*\\()'
    'beginCaptures':
      '1': 'name': 'support.type.derived-type.fortran2008'
    'end': '(?=[;!\\n])'
    'patterns': [
      {# attribute list
        'comment': 'derived-type attribute list'
        'begin': '(?i)(?<=type)\\b(?![\\t ]*\\()'
        'end': '(?i)(::)|(?=[a-z]|[;!\\n])'
        'endCaptures':
          '1': 'name': 'keyword.operator.double-colon.fortran'
        'patterns': [
          {
            'begin': '(?i)(,)'
            'beginCaptures':
              '1': 'name': 'punctuation.comma.fortran'
            'end': '(?=::|[,;!\\n])'
            'patterns':[
              {'include': '#access-attributes'}
              {
                'begin': '(?i)\\b(extends)\\s*\\((?!([^;!\n](?!::))*(sequence))'
                'beginCaptures':
                  '1': 'name': 'keyword.other.attribute.derived-type.fortran.2008'
                'end': '\\)'
                'patterns':[
                  {
                    'name': 'entity.name.derived-type.fortran.2008'
                    'match': '(?i)\\b([a-z]\\w*)\\b'
                  }
                ]
              }
              {
                'begin': '\\b(bind)\\s*\\('
                'beginCaptures':
                  '1': 'name': 'keyword.other.attribute.derived-type.fortran.2008'
                'end': '\\)'
                'patterns':[
                  {
                    'name': 'entity.name.bound-type.fortran.2008'
                    'match': '(?i)\\b(c)\\b'
                  }
                ]
              }
              {
                'name': 'keyword.other.attribute.derived-type.fortran.2008'
                'match': '(?i)\\b(sequence)\\b(?!([^;!\n](?!::))*(extends))'
              }
              {
                'name': 'invalid.error.fortran'
                'match': '(?i)\\b\\w+\\b'
              }
            ]
          }
        ]
      }
      {# body
        'begin': '(?i)\\b([a-z]\\w*)\\b'
        'beginCaptures':
          '1': 'name': 'entity.name.derived-type.fortran.2008'
        'end': '(?i)^\\s*(end)[\\t ]*(type)(?:\\s+(?:(\\1)|(\\w+)))?\\b'
        'endCaptures':
          '1': 'name': 'keyword.control.end.derived-type.fortran.2008'
          '2': 'name': 'support.type.derived-type.fortran.2008'
          '3': 'name': 'entity.name.derived-type.fortran.2008'
          '4': 'name': 'invalid.error.fortran.2008'
        'patterns':[
          {'include': '$base'}
          {# parameter definition statements
            'match': '(?i)^\\s*(integer)[\\t ]*(,)\\s*(kind|len)\\s*(?:(::)\\s*([a-z]\\w*)?)?\\s*(?=[;!\\n])'
            'captures':
              '1': 'name': 'storage.type.integer.fortran'
              '2': 'name': 'punctuation.comma.fortran'
              '3': 'name': 'keyword.other.attribute.derived-type.parameter.fortran.2008'
              '4': 'name': 'keyword.operator.double-colon.fortran'
              '5': 'name': 'entity.name.derived-type.parameter.fortran.2008'
          }
          {# attribute statements
            'name': 'keyword.other.attribute.derived-type.fortran.2008'
            'match': '(?i)^\\s*(private|public|sequence)\\b\\s*\\n'
          }
          {# contains section
            'comment': 'derived-type contains construct'
            'begin': '(?i)^\\s*(contains)(?=\\s*[!$\\n])'
            'beginCaptures':
              '1': 'name': 'keyword.type-contains.fortran2008'
            'end': '(?i)(?=\\s+end\\b)'
            'patterns': [
              {'include': '$base'}
              {
                'name': 'keyword.other.attribute.statement.fortran.2008'
                'match': '(?i)^\\s*private\\b'
              }
              {# generic procedure statement
                'begin': '(?i)^\\s*(generic)\\b'
                'beginCaptures':
                  '1': 'name': 'support.function.generic.type-bound.fortran.2008'
                'end': '(?=[;!\\n])'
                'patterns':[
                  {# attribute list
                    'comment': 'derived-type attribute list'
                    'begin': '(?i)(?<=generic)'
                    'end': '(?i)(::)|(?=[a-z]|[;!\\n])'
                    'endCaptures':
                      '1': 'name': 'keyword.operator.double-colon.fortran'
                    'patterns': [
                      {
                        'begin': '(?i)(,)'
                        'beginCaptures':
                          '1': 'name': 'punctuation.comma.fortran'
                        'end': '(?=::|[,;!\\n])'
                        'patterns':[
                          {'include': '#access-attributes'}
                        ]
                      }
                    ]
                  }
                  {# assignment
                    'comment': 'type bound procedure binding name'
                    'match': '(?i)(?<=generic|::)[\\t ]*\\b(assignment)[\\t ]*\\([\\t ]*(\\=)[\\t ]*\\)'
                    'captures':
                      '1': 'name': 'keyword.other.assignment.fortran.2008'
                      '2': 'name': 'keyword.operator.fortran.2008'
                  }
                  {# operator
                    'comment': 'type bound procedure binding name'
                    'match': '(?i)(?<=generic|::)[\\t ]*\\b(operator)[\\t ]*\\([\\t ]*(\\.[a-z]*\\.|\\=\\=|\\>\\=|\\<\\=|\\/\\=|\\>|\\<)[\\t ]*\\)'
                    'captures':
                      '1': 'name': 'keyword.other.assignment.fortran.2008'
                      '2': 'name': 'keyword.operator.fortran.2008'
                  }
                  {# binding list
                    'begin': '\\=\\>'
                    'beginCaptures':
                      '0': 'name': 'keyword.operator.pointer.fortran.2008'
                    'end': '(?=[;!\\n])'
                    'patterns':[
                      {
                        'name': 'entity.name.function.procedure.fortran.2008'
                        'match': '(?i)\\b[a-z]\\w*\\b'
                      }
                    ]
                  }
                ]
              }
              {# procedure statement
                'comment': 'type bound procedure statement'
                'begin': '(?i)^\\s*(procedure)\\b(?:[\\t ]*\\(([a-z]\\w*)\\))?'
                'beginCaptures':
                  '1': 'name': 'support.function.procedure.type-bound.fortran.2008'
                  '2': 'name': 'entity.name.function.procedure.fortran.2008'
                'end': '(?i)(?=[;!$\\n])'
                'patterns':[
                  {# attribute list
                    'comment': 'derived-type attribute list'
                    'begin': '(?i)(?<=procedure|\\))\\b(?![\\t ]*\\()'
                    'end': '(?i)(::)|(?=[a-z]|[;!\\n])'
                    'endCaptures':
                      '1': 'name': 'keyword.operator.double-colon.fortran'
                    'patterns': [
                      {
                        'begin': '(?i)(,)'
                        'beginCaptures':
                          '1': 'name': 'punctuation.comma.fortran'
                        'end': '(?=::|[,;!\\n])'
                        'patterns':[
                          {'include': '#access-attributes'}
                          {
                            'match': '(?i)\\b(pass)\\b[\\t ]*(?:\\([\\t ]*([a-z]\\w*)[\\t ]*\\))?(?!([^;!\n](?!::))*(nopass|pass))'
                            'captures':
                              '1': 'name': 'keyword.other.attribute.procedure.fortran.2008'
                              '2': 'name': 'keyword.other.attribute.procedure.fortran.2008'
                            'end': '(?=[,:;!\\n])'
                          }
                          {
                            'name': 'keyword.other.attribute.procedure.fortran.2008'
                            'match': '(?i)\\b(nopass)\\b(?!([^;!\n](?!::))*(nopass|pass))'
                          }
                          {
                            'name': 'keyword.other.attribute.procedure.fortran.2008'
                            'match': '(?i)\\b(deferred|non_overridable)\\b(?!([^;!\n](?!::))*(deferred|non_overridable))'
                          }
                          {
                            'name': 'invalid.error.fortran'
                            'match': '(?i)\\b\\w+\\b'
                          }
                        ]
                      }
                    ]
                  }
                  {# binding name
                    'comment': 'type bound procedure binding name'
                    'match': '(?i)(?<=procedure|::)[\\t ]*\\b([a-z]\\w*\\b)(?:[\\t ]*(\\=\\>)(?:[\\t ]*([a-z]\\w*\\b))?)?'
                    'captures':
                      '1': 'name': 'entity.name.function.procedure.fortran.2008'
                      '2': 'name': 'keyword.other.operator.fortran.2008'
                      '3': 'name': 'entity.name.function.procedure.fortran.2008'
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
  {
    'begin': '(^[ \\t]+)?(?=!-)'
    'beginCaptures':
      '1':
        'name': 'punctuation.whitespace.comment.leading.ruby'
    'end': '(?!\\G)'
    'patterns': [
      {
        'begin': '!-'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.fortran'
        'end': '\\n'
        'name': 'comment.line.exclamation.mark.fortran.modern'
        'patterns': [
          {
            'match': '\\\\\\s*\\n'
          }
        ]
      }
    ]
  }
  {
    'begin': '(^[ \\t]+)?(?=!)'
    'beginCaptures':
      '1':
        'name': 'punctuation.whitespace.comment.leading.ruby'
    'end': '(?!\\G)'
    'patterns': [
      {
        'begin': '!'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.fortran'
        'end': '\\n'
        'name': 'comment.line.exclamation.fortran.modern'
        'patterns': [
          {
            'match': '\\\\\\s*\\n'
          }
        ]
      }
    ]
  }
  {
    'comment': 'statements controling the flow of the program'
    'match': '(?i)\\b(select\\s+case|case(\\s+default)?|end\\s+select|use|(end\\s+)?forall)\\b'
    'name': 'keyword.control.fortran.modern'
  }
  {
    'comment': 'input/output instrinsics'
    'match': '(?i)\\b(access|action|advance|append|apostrophe|asis|blank|delete|delim|direct|end|eor|err|exist|file|fmt|form|formatted|iolength|iostat|keep|name|named|nextrec|new|nml|no|null|number|old|opened|pad|position|quote|read|readwrite|rec|recl|replace|scratch|sequential|size|status|undefined|unformatted|unit|unknown|write|yes|zero|namelist)(?=\\()'
    'name': 'keyword.control.io.fortran.modern'
  }
  {
    'comment': 'logical operators in symbolic format'
    'match': '\\b(\\=\\=|\\/\\=|\\>\\=|\\>|\\<|\\<\\=)\\b'
    'name': 'keyword.operator.logical.fortran.modern'
  }
  {
    'comment': 'operators'
    'match': '(\\%|\\=\\>)'
    'name': 'keyword.operator.fortran.modern'
  }
  {
    'comment': 'numeric instrinsics'
    'match': '(?i)\\b(ceiling|floor|modulo)(?=\\()'
    'name': 'keyword.other.instrinsic.numeric.fortran.modern'
  }
  {
    'comment': 'matrix/vector/array instrinsics'
    'match': '(?i)\\b(allocate|allocated|deallocate)(?=\\()'
    'name': 'keyword.other.instrinsic.array.fortran.modern'
  }
  {
    'comment': 'pointer instrinsics'
    'match': '(?i)\\b(associated)(?=\\()'
    'name': 'keyword.other.instrinsic.pointer.fortran.modern'
  }
  {
    'comment': 'programming units'
    'match': '\\b(?i:((end\\s*)?(interface|procedure|module)))\\b'
    'name': 'keyword.other.programming-units.fortran.modern'
  }
  {
    'begin': '\\b(?i:(type(?=\\s*\\()))\\b(?=.*::)'
    'beginCaptures':
      '1':
        'name': 'storage.type.fortran.modern'
    'comment': 'Line of type specification'
    'end': '(?=!)|$'
    'name': 'meta.specification.fortran.modern'
    'patterns': [
      {
        'include': '$base'
      }
    ]
  }
  {
    'match': '\\b(?i:(type(?=\\s*\\()))\\b'
    'name': 'storage.type.fortran.modern'
  }
  {
    'match': '\\b(?i:(optional|recursive|pointer|allocatable|target|private|public))\\b'
    'name': 'storage.modifier.fortran.modern'
  }
]
'repository':
  'access-attributes':
    {
      'name': 'keyword.other.attribute.fortran.1990'
      'match': '(?i)\\b(private|public)\\b(?!([^;!\n](?!::))*\\b(private|public)\\b)'
    }
  # interfaces:
  'interface-blocks':
    'patterns':[
      {'include': '#abstract-interface-block'}
      {'include': '#assignment-interface-block'}
      {'include': '#explicit-interface-block'}
      {'include': '#generic-interface-block'}
      {'include': '#IO-interface-block'}
      {'include': '#operator-interface-block'}
    ]
  'abstract-interface-block':
    'begin': '(?i)^\\s*(abstract)\\b(\\s*\\binterface\\b)?\\s*(\\b\\w+\\b)?'
    'beginCaptures':
      '1': 'name': 'keyword.other.attribute.fortran.2008'
      '2': 'name': 'support.function.interface.fortran.2008'
      '3': 'name': 'invalid.error.fortran'
    'end': '(?i)^\\s*(end)\\s*(interface)\\b\\s*(\\b\\w+\\b)?'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.1990'
      '2': 'name': 'support.function.interface.fortran.1990'
      '3': 'name': 'invalid.error.fortran'
    'patterns': [
      {'include': '$self'}
    ]
  'assignment-interface-block':
    'begin': '(?i)^\\s*(interface)\\s+(assignment)\\b\\s*\\(\\s*(?:(=)|([^\\s]*))\\s*\\)\\s*([^;!\\n]*)?'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.1990'
      '2': 'name': 'keyword.other.operator.fortran.1990'
      '3': 'name': 'keyword.operator.fortran.1990'
      '4': 'name': 'invalid.error.fortran'
      '5': 'name': 'invalid.error.fortran'
    'end': '(?ix)^\\s*(end)\\s*(?:(interface)\\b(?:\\s+(assignment)\\b(?:\\s*\\((?:(\\s*\\3\\s*)|(.+))?\\))?)?)?\\s*([^;!\\n]*)'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.1990'
      '2': 'name': 'support.function.interface.fortran.1990'
      '3': 'name': 'keyword.other.operator.fortran.1990'
      '4': 'name': 'keyword.operator.fortran.1990'
      '5': 'name': 'invalid.error.fortran'
      '6': 'name': 'invalid.error.fortran'
    'patterns':[
      {'include': '#interface-body'}
    ]
  'explicit-interface-block':
    'begin': '(?i)^\\s*(interface)\\s*(?=[;!\\n])'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.1990'
    'end': '(?i)^\\s*(end)\\s*(?:(interface))?'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.1990'
      '2': 'name': 'support.function.interface.fortran.1990'
    'patterns':[
      {'include': '#interface-body'}
    ]
  'generic-interface-block':
    'begin': '(?i)^\\s*(interface)\\b\\s*([a-z]\\w*)\\b\\s*(?=[;!\\n])'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.1990'
      '2': 'name': 'entity.name.function.fortran'
    'end': '(?i)^\\s*(end)\\s*(?:(interface)(?:\\s+(\\2))?\\b)?(?:\\s*\\b([^\\s;!\\n]*))?'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.1990'
      '2': 'name': 'support.function.interface.fortran.1990'
      '3': 'name': 'entity.name.function.fortran'
      '4': 'name': 'invalid.error.fortran'
    'patterns':[
      {'include': '#interface-body'}
    ]
  'IO-interface-block':
    'begin': '(?i)^\\s*(interface)\\s+(read|write)\\s*\\(\\s*(?:((?:un)?formatted)|(.*))\\s*\\)\\s*([^;!\\n]*)?'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.1990'
      '2': 'name': 'keyword.other.operator.fortran.1990'
      '3': 'name': 'keyword.other.operator.fortran.1990'
      '4': 'name': 'invalid.error.fortran'
      '5': 'name': 'invalid.error.fortran'
    'end': '(?ix)^\\s*(end)\\s*(?:(interface)\\b(?:\\s+(\\2)\\b(?:\\s*\\((?:(\\s*\\3\\s*)|(.+))?\\))?)?)?\\s*([^;!\\n]*)'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.1990'
      '2': 'name': 'support.function.interface.fortran.1990'
      '3': 'name': 'keyword.other.operator.fortran.1990'
      '4': 'name': 'keyword.other.operator.fortran.1990'
      '5': 'name': 'invalid.error.fortran'
      '6': 'name': 'invalid.error.fortran'
    'patterns':[
      {'include': '#interface-body'}
    ]
  'operator-interface-block':
    'begin': '(?i)^\\s*(interface)\\s+(operator)\\b\\s*\\(\\s*(?:(\\.[a-z]+\\.|\\+|\\-|\\*\\*?|\\/[\\/\\=]?|[\\<\\>]\\=?|\\=\\=)|([^\\s]*))\\s*\\)\\s*([^;!\\n]*)?'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.1990'
      '2': 'name': 'keyword.other.operator.fortran.1990'
      '3': 'name': 'keyword.operator.fortran.1990'
      '4': 'name': 'invalid.error.fortran'
      '5': 'name': 'invalid.error.fortran'
    'end': '(?i)^\\s*(end)\\s*(?:(interface)\\b(?:\\s+(operator)\\b(?:\\s*\\((?:(\\s*\\3\\s*)|(.+))?\\))?)?)?\\s*([^;!\\n]*)'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.1990'
      '2': 'name': 'support.function.interface.fortran.1990'
      '3': 'name': 'keyword.other.operator.fortran.1990'
      '4': 'name': 'keyword.operator.fortran.1990'
      '5': 'name': 'invalid.error.fortran'
      '6': 'name': 'invalid.error.fortran'
    'patterns':[
      {'include': '#interface-body'}
    ]
  'interface-body':
    'patterns':[
      {'include': '$self'}
      {'include': '#module-procedure-statement'}
      {'include': '#procedure-statement'}
    ]
  'procedure-statement':
    'begin': '(?i)(?:\\G|^)\\s*\\b(procedure)\\b(\\s*::)?'
    'beginCaptures':
      '1': 'name': 'support.function.procedure.fortran.1990'
      '2': 'name': 'keyword.operator.fortran.1990'
    'end': '(?i)(?=[;!\\n])'
    'patterns':[
      {
        'match': '(?i)(?:\\G|(,))\\s*\\b([a-z]\\w*)\\b'
        'captures':
          '1': 'name': 'punctuation.separator.comma.fortran'
          '2': 'name': 'entity.name.function.procedure.fortran'
      }
    ]
  'module-procedure-statement':
    'begin': '(?i)^\\s*\\b(module)\\b'
    'beginCaptures':
      '1': 'name': 'keyword.other.module.fortran.1990'
    'end': '(?i)(?=[;!\\n])'
    'patterns':[
      {'include': '#procedure-statement'}
    ]

'scopeName': 'source.fortran.modern'
