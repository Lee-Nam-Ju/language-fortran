'comment': 'Specificities of Fortran >= 90'
'fileTypes': [
  'f90'
  'F90'
  'f95'
  'F95'
  'f03'
  'F03'
  'f08'
  'F08'
]
'firstLineMatch': '(?i)-[*]- mode: f90 -[*]-'
'name': 'Fortran - Modern'
'patterns': [
  {
    'include': 'source.fortran'
  }
  {'include': '#interface-block'}
  # {
  #   'begin': '(?i)^\\s*(interface)\\s+(operator|assignment)\\(((\\.[a-z0-9_]+\\.)|[\\+\\-\\=\\/\\*]+)\\)'
  #   'beginCaptures':
  #     '1':
  #       'name': 'storage.type.function.fortran'
  #     '2':
  #       'name': 'storage.type.fortran'
  #     '3':
  #       'name': 'keyword.operator.fortran'
  #   'comment': 'Interface declaration of operator/assignments'
  #   'end': '(?i)(end)\\s*(interface)?'
  #   'endCaptures':
  #     '1':
  #       'name': 'keyword.other.fortran'
  #     '2':
  #       'name': 'storage.type.function.fortran'
  #   'name': 'meta.function.interface.operator.fortran.modern'
  #   'patterns': [
  #     {
  #       'include': '$self'
  #     }
  #   ]
  # }
  # {
  #   'begin': '(?i)^\\s*(interface)\\s+([a-z]\\w*)'
  #   'beginCaptures':
  #     '1':
  #       'name': 'storage.type.function.fortran'
  #     '2':
  #       'name': 'entity.name.function.fortran'
  #   'comment': 'Interface declaration of function/subroutines'
  #   'end': '(?i)(end)\\s*(interface)?'
  #   'endCaptures':
  #     '1':
  #       'name': 'keyword.other.fortran'
  #     '2':
  #       'name': 'storage.type.function.fortran'
  #   'name': 'meta.function.interface.fortran.modern'
  #   'patterns': [
  #     {
  #       'include': '$self'
  #     }
  #   ]
  # }
  {
    'name': 'meta.derived-type.definition.fortran2008'
    'begin': '(?i)^\\s*(type)\\b(?![\\t ]*\\()'
    'beginCaptures':
      '1': 'name': 'support.type.derived-type.fortran2008'
    'end': '(?=[;!\\n])'
    'patterns': [
      {# attribute list
        'comment': 'derived-type attribute list'
        'begin': '(?i)(?<=type)\\b(?![\\t ]*\\()'
        'end': '(?i)(::)|(?=[a-z]|[;!\\n])'
        'endCaptures':
          '1': 'name': 'keyword.operator.double-colon.fortran'
        'patterns': [
          {
            'begin': '(?i)(,)'
            'beginCaptures':
              '1': 'name': 'punctuation.comma.fortran'
            'end': '(?=::|[,;!\\n])'
            'patterns':[
              {'include': '#access-attributes'}
              {
                'begin': '(?i)\\b(extends)[\\t ]*\\((?!([^;!\n](?!::))*(sequence))'
                'beginCaptures':
                  '1': 'name': 'keyword.other.attribute.derived-type.fortran.2008'
                'end': '\\)'
                'patterns':[
                  {
                    'name': 'entity.name.derived-type.fortran.2008'
                    'match': '(?i)\\b([a-z]\\w*)\\b'
                  }
                ]
              }
              {
                'begin': '\\b(bind)[\\t ]*\\('
                'beginCaptures':
                  '1': 'name': 'keyword.other.attribute.derived-type.fortran.2008'
                'end': '\\)'
                'patterns':[
                  {
                    'name': 'entity.name.bound-type.fortran.2008'
                    'match': '(?i)\\b(c)\\b'
                  }
                ]
              }
              {
                'name': 'keyword.other.attribute.derived-type.fortran.2008'
                'match': '(?i)\\b(sequence)\\b(?!([^;!\n](?!::))*(extends))'
              }
              {
                'name': 'invalid.error.fortran'
                'match': '(?i)\\b\\w+\\b'
              }
            ]
          }
        ]
      }
      {# body
        'begin': '(?i)\\b([a-z]\\w*)\\b'
        'beginCaptures':
          '1': 'name': 'entity.name.derived-type.fortran.2008'
        'end': '(?i)^\\s*(end)[\\t ]*(type)(?:[\\t ]+(?:(\\1)|(\\w+)))?\\b'
        'endCaptures':
          '1': 'name': 'keyword.control.end.derived-type.fortran.2008'
          '2': 'name': 'support.type.derived-type.fortran.2008'
          '3': 'name': 'entity.name.derived-type.fortran.2008'
          '4': 'name': 'invalid.error.fortran.2008'
        'patterns':[
          {'include': '$base'}
          {# parameter definition statements
            'match': '(?i)^\\s*(integer)[\\t ]*(,)[\\t ]*(kind|len)[\\t ]*(?:(::)[\\t ]*([a-z]\\w*)?)?[\\t ]*(?=[;!\\n])'
            'captures':
              '1': 'name': 'storage.type.integer.fortran'
              '2': 'name': 'punctuation.comma.fortran'
              '3': 'name': 'keyword.other.attribute.derived-type.parameter.fortran.2008'
              '4': 'name': 'keyword.operator.double-colon.fortran'
              '5': 'name': 'entity.name.derived-type.parameter.fortran.2008'
          }
          {# attribute statements
            'name': 'keyword.other.attribute.derived-type.fortran.2008'
            'match': '(?i)^\\s*(private|public|sequence)\\b\\s*\\n'
          }
          {# contains section
            'comment': 'derived-type contains construct'
            'begin': '(?i)^\\s*(contains)(?=\\s*[!$\\n])'
            'beginCaptures':
              '1': 'name': 'keyword.type-contains.fortran2008'
            'end': '(?i)(?=\\s+end\\b)'
            'patterns': [
              {'include': '$base'}
              {
                'name': 'keyword.other.attribute.statement.fortran.2008'
                'match': '(?i)^\\s*private\\b'
              }
              {# generic procedure statement
                'begin': '(?i)^\\s*(generic)\\b'
                'beginCaptures':
                  '1': 'name': 'support.function.generic.type-bound.fortran.2008'
                'end': '(?=[;!\\n])'
                'patterns':[
                  {# attribute list
                    'comment': 'derived-type attribute list'
                    'begin': '(?i)(?<=generic)'
                    'end': '(?i)(::)|(?=[a-z]|[;!\\n])'
                    'endCaptures':
                      '1': 'name': 'keyword.operator.double-colon.fortran'
                    'patterns': [
                      {
                        'begin': '(?i)(,)'
                        'beginCaptures':
                          '1': 'name': 'punctuation.comma.fortran'
                        'end': '(?=::|[,;!\\n])'
                        'patterns':[
                          {'include': '#access-attributes'}
                        ]
                      }
                    ]
                  }
                  {# assignment
                    'comment': 'type bound procedure binding name'
                    'match': '(?i)(?<=generic|::)[\\t ]*\\b(assignment)[\\t ]*\\([\\t ]*(\\=)[\\t ]*\\)'
                    'captures':
                      '1': 'name': 'keyword.other.assignment.fortran.2008'
                      '2': 'name': 'keyword.operator.fortran.2008'
                  }
                  {# operator
                    'comment': 'type bound procedure binding name'
                    'match': '(?i)(?<=generic|::)[\\t ]*\\b(operator)[\\t ]*\\([\\t ]*(\\.[a-z]*\\.|\\=\\=|\\>\\=|\\<\\=|\\/\\=|\\>|\\<)[\\t ]*\\)'
                    'captures':
                      '1': 'name': 'keyword.other.assignment.fortran.2008'
                      '2': 'name': 'keyword.operator.fortran.2008'
                  }
                  {# binding list
                    'begin': '\\=\\>'
                    'beginCaptures':
                      '0': 'name': 'keyword.operator.pointer.fortran.2008'
                    'end': '(?=[;!\\n])'
                    'patterns':[
                      {
                        'name': 'entity.name.function.procedure.fortran.2008'
                        'match': '(?i)\\b[a-z]\\w*\\b'
                      }
                    ]
                  }
                ]
              }
              {# procedure statement
                'comment': 'type bound procedure statement'
                'begin': '(?i)^\\s*(procedure)\\b(?:[\\t ]*\\(([a-z]\\w*)\\))?'
                'beginCaptures':
                  '1': 'name': 'support.function.procedure.type-bound.fortran.2008'
                  '2': 'name': 'entity.name.function.procedure.fortran.2008'
                'end': '(?i)(?=[;!$\\n])'
                'patterns':[
                  {# attribute list
                    'comment': 'derived-type attribute list'
                    'begin': '(?i)(?<=procedure|\\))\\b(?![\\t ]*\\()'
                    'end': '(?i)(::)|(?=[a-z]|[;!\\n])'
                    'endCaptures':
                      '1': 'name': 'keyword.operator.double-colon.fortran'
                    'patterns': [
                      {
                        'begin': '(?i)(,)'
                        'beginCaptures':
                          '1': 'name': 'punctuation.comma.fortran'
                        'end': '(?=::|[,;!\\n])'
                        'patterns':[
                          {'include': '#access-attributes'}
                          {
                            'match': '(?i)\\b(pass)\\b[\\t ]*(?:\\([\\t ]*([a-z]\\w*)[\\t ]*\\))?(?!([^;!\n](?!::))*(nopass|pass))'
                            'captures':
                              '1': 'name': 'keyword.other.attribute.procedure.fortran.2008'
                              '2': 'name': 'keyword.other.attribute.procedure.fortran.2008'
                            'end': '(?=[,:;!\\n])'
                          }
                          {
                            'name': 'keyword.other.attribute.procedure.fortran.2008'
                            'match': '(?i)\\b(nopass)\\b(?!([^;!\n](?!::))*(nopass|pass))'
                          }
                          {
                            'name': 'keyword.other.attribute.procedure.fortran.2008'
                            'match': '(?i)\\b(deferred|non_overridable)\\b(?!([^;!\n](?!::))*(deferred|non_overridable))'
                          }
                          {
                            'name': 'invalid.error.fortran'
                            'match': '(?i)\\b\\w+\\b'
                          }
                        ]
                      }
                    ]
                  }
                  {# binding name
                    'comment': 'type bound procedure binding name'
                    'match': '(?i)(?<=procedure|::)[\\t ]*\\b([a-z]\\w*\\b)(?:[\\t ]*(\\=\\>)(?:[\\t ]*([a-z]\\w*\\b))?)?'
                    'captures':
                      '1': 'name': 'entity.name.function.procedure.fortran.2008'
                      '2': 'name': 'keyword.other.operator.fortran.2008'
                      '3': 'name': 'entity.name.function.procedure.fortran.2008'
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
  # {
  #   'begin': '(?i)^\\s*(type)\\s+([a-z]\\w*)'
  #   'beginCaptures':
  #     '1':
  #       'name': 'storage.type.fortran.modern'
  #     '2':
  #       'name': 'entity.name.type.fortran.modern'
  #   'comment': 'Type definition'
  #   'end': '(?i)(end)\\s*(?:(type)(\\s+[a-z]\\w*)?)'
  #   'endCaptures':
  #     '1':
  #       'name': 'keyword.other.fortran'
  #     '2':
  #       'name': 'storage.type.fortran.modern'
  #     '3':
  #       'name': 'entity.name.type.end.fortran.modern'
  #   'name': 'meta.type-definition.fortran.modern'
  #   'patterns': [
  #     {
  #       'include': '$self'
  #     }
  #   ]
  # }
  {
    'begin': '(^[ \\t]+)?(?=!-)'
    'beginCaptures':
      '1':
        'name': 'punctuation.whitespace.comment.leading.ruby'
    'end': '(?!\\G)'
    'patterns': [
      {
        'begin': '!-'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.fortran'
        'end': '\\n'
        'name': 'comment.line.exclamation.mark.fortran.modern'
        'patterns': [
          {
            'match': '\\\\\\s*\\n'
          }
        ]
      }
    ]
  }
  {
    'begin': '(^[ \\t]+)?(?=!)'
    'beginCaptures':
      '1':
        'name': 'punctuation.whitespace.comment.leading.ruby'
    'end': '(?!\\G)'
    'patterns': [
      {
        'begin': '!'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.fortran'
        'end': '\\n'
        'name': 'comment.line.exclamation.fortran.modern'
        'patterns': [
          {
            'match': '\\\\\\s*\\n'
          }
        ]
      }
    ]
  }
  {
    'comment': 'statements controling the flow of the program'
    'match': '(?i)\\b(select\\s+case|case(\\s+default)?|end\\s+select|use|(end\\s+)?forall)\\b'
    'name': 'keyword.control.fortran.modern'
  }
  {
    'comment': 'input/output instrinsics'
    'match': '(?i)\\b(access|action|advance|append|apostrophe|asis|blank|delete|delim|direct|end|eor|err|exist|file|fmt|form|formatted|iolength|iostat|keep|name|named|nextrec|new|nml|no|null|number|old|opened|pad|position|quote|read|readwrite|rec|recl|replace|scratch|sequential|size|status|undefined|unformatted|unit|unknown|write|yes|zero|namelist)(?=\\()'
    'name': 'keyword.control.io.fortran.modern'
  }
  {
    'comment': 'logical operators in symbolic format'
    'match': '\\b(\\=\\=|\\/\\=|\\>\\=|\\>|\\<|\\<\\=)\\b'
    'name': 'keyword.operator.logical.fortran.modern'
  }
  {
    'comment': 'operators'
    'match': '(\\%|\\=\\>)'
    'name': 'keyword.operator.fortran.modern'
  }
  {
    'comment': 'numeric instrinsics'
    'match': '(?i)\\b(ceiling|floor|modulo)(?=\\()'
    'name': 'keyword.other.instrinsic.numeric.fortran.modern'
  }
  {
    'comment': 'matrix/vector/array instrinsics'
    'match': '(?i)\\b(allocate|allocated|deallocate)(?=\\()'
    'name': 'keyword.other.instrinsic.array.fortran.modern'
  }
  {
    'comment': 'pointer instrinsics'
    'match': '(?i)\\b(associated)(?=\\()'
    'name': 'keyword.other.instrinsic.pointer.fortran.modern'
  }
  {
    'comment': 'programming units'
    'match': '\\b(?i:((end\\s*)?(interface|procedure|module)))\\b'
    'name': 'keyword.other.programming-units.fortran.modern'
  }
  {
    'begin': '\\b(?i:(type(?=\\s*\\()))\\b(?=.*::)'
    'beginCaptures':
      '1':
        'name': 'storage.type.fortran.modern'
    'comment': 'Line of type specification'
    'end': '(?=!)|$'
    'name': 'meta.specification.fortran.modern'
    'patterns': [
      {
        'include': '$base'
      }
    ]
  }
  {
    'match': '\\b(?i:(type(?=\\s*\\()))\\b'
    'name': 'storage.type.fortran.modern'
  }
  {
    'match': '\\b(?i:(optional|recursive|pointer|allocatable|target|private|public))\\b'
    'name': 'storage.modifier.fortran.modern'
  }
]
'repository':
  'access-attributes':
    {
      'name': 'keyword.other.attribute.fortran.1990'
      'match': '(?i)\\b(private|public)\\b(?!([^;!\n](?!::))*\\b(private|public)\\b)'
    }
  # interfaces:
  'interface-block':
    'comment': 'Interfaces were first introduced in the Fortran 1990 standard.'
    'patterns':[
      {'include': '#abstract-interface-block'}
      {'include': '#assignment-interface-block'}
      {'include': '#operator-interface-block'}
      {'include': '#generic-interface-block'}
    ]
  'abstract-interface-block':
    'comment': 'Abstract interfaces were introduced in the Fortran 2003 standard.'
    'begin': '(?i)^\\s*(abstract)\\b'
    'beginCaptures':
      '1': 'name': 'keyword.other.attribute.fortran.2003'
    'end': '(?=[;!\\n])'
    'patterns':[
      {'include': '#generic-interface-block'}
      {'include': '#assignment-interface-block'}
      {'include': '#operator-interface-block'}
    ]
  'assignment-interface-block':
    'comment': 'Assignment interfaces were introduced in the Fortran 1990 standard.'
    'begin': '(?i)(?:^|\\G)\\s*(interface)\\s*\\b(assignment)\\s*\\(\\s*(\\=)\\s*\\)'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.modern'
      '2': 'name': 'keyword.other.assignment.fortran.modern'
      '3': 'name': 'keyword.operator.fortran.modern'
    'end': '(?i)^\\s*(end)\\s*(interface)\\s*(?:\\b(assignment)\\s*\\(\\s*(?:(\\3)|([^\\s\\(\\)]*))\\s*\\))?'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.modern'
      '2': 'name': 'support.function.interface.fortran.modern'
      '3': 'name': 'keyword.other.assignment.fortran.modern'
      '4': 'name': 'keyword.operator.fortran.modern'
      '5': 'name': 'invalid.error.fortran'
    'patterns':[
      {'include': '#procedure-statement'}
      {'include': '$self'}
    ]
  'generic-interface-block':
    'comment': 'Generic interfaces were introduced in the Fortran 1990 standard.'
    'begin': '(?i)(?:^|\\G)\\s*(interface)\\s*(\\b[a-z]\\w*\\b)?'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.modern'
      '2': 'name': 'entity.name.function.fortran'
    'end': '(?i)^\\s*(end)\\s*(interface)\\s*(\\b\\2\\b)?(\\b\\w+\\b)?'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.modern'
      '2': 'name': 'support.function.interface.fortran.modern'
      '3': 'name': 'entity.name.function.fortran.modern'
      '4': 'name': 'invalid.error.fortran.modern'
    'patterns':[
      {'include': '#procedure-statement'}
      {'include': '$self'}
    ]
  'operator-interface-block':
    'comment': 'Operator interfaces were introduced in the Fortran 1990 standard.'
    'begin': '(?i)(?:^|\\G)\\s*(interface)\\s+(operator)\\s*\\(\\s*(\\.[a-z]+\\.)\\s*\\)'
    'beginCaptures':
      '1': 'name': 'support.function.interface.fortran.modern'
      '2': 'name': 'keyword.other.operator.fortran.modern'
      '3': 'name': 'keyword.operator.fortran.modern'
    'end': '(?i)^\\s*(end)\\s*(interface)\\b\\s*(?:\\b(operator)\\s*\\(\\s*(?:(\\3)|([^\\s\\(\\)]*))\\s*\\))?([^;!\\n]*)?'
    'endCaptures':
      '1': 'name': 'keyword.control.end.fortran.modern'
      '2': 'name': 'support.function.interface.fortran.modern'
      '3': 'name': 'keyword.other.operator.fortran.modern'
      '4': 'name': 'keyword.operator.fortran.modern'
      '5': 'name': 'invalid.error.fortran.modern'
    'patterns':[
      {'include': '#procedure-statement'}
      {'include': '$self'}
    ]
  'procedure-statement':
    'begin': '(?i)^\\s*(module\\s+)?(procedure)\\b(\\s*::)?'
    'beginCaptures':
      '1': 'name': 'keyword.other.module.fortran.modern'
      '2': 'name': 'support.function.procedure.fortran.modern'
      '3': 'name': 'keyword.operator.fortran.modern'
    'end': '(?i)(?=\\s*[;!\\n])'
    'patterns':[
      {
        'name': 'entity.name.function.procedure.fortran'
        'match': '(?i)(?<=procedure|::|,)\\s*[a-z]\\w*'
      }
    ]
'scopeName': 'source.fortran.modern'
